{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/entrypoints/service-worker-hass.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","160","workbox","setConfig","debug","skipWaiting","clientsClaim","precaching","precacheAndRoute","self","__precacheManifest","routing","registerRoute","RegExp","location","host","strategies","cacheFirst","networkOnly","staleWhileRevalidate","firePushCallback","payload","jwt","data","keys","length","constructor","fetch","method","headers","Headers","Content-Type","Authorization","body","JSON","stringify","notificationEventCallback","eventType","event","action","notification","tag","type","addEventListener","json","waitUntil","registration","showNotification","title","then","url","close","clients","matchAll","windowClients","client","focus","openWindow"],"mappings":"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","file":"service-worker-hass.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/frontend_latest/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 160);\n","/* global workbox clients */\n\nfunction initRouting() {\n  workbox.precaching.precacheAndRoute(self.__precacheManifest || []);\n\n  // Cache static content (including translations) on first access.\n  workbox.routing.registerRoute(\n    new RegExp(`${location.host}/(static|frontend_latest|frontend_es5)/.+`),\n    workbox.strategies.cacheFirst()\n  );\n\n  // Get api from network.\n  workbox.routing.registerRoute(\n    new RegExp(`${location.host}/api/.*`),\n    workbox.strategies.networkOnly()\n  );\n\n  // Get manifest and service worker from network.\n  workbox.routing.registerRoute(\n    new RegExp(`${location.host}/(service_worker.js|service_worker_es5.js|manifest.json)`),\n    workbox.strategies.networkOnly()\n  );\n\n  // For rest of the files (on Home Assistant domain only) try both cache and network.\n  // This includes the root \"/\" or \"/states\" response and user files from \"/local\".\n  // First access might bring stale data from cache, but a single refresh will bring updated\n  // file.\n  workbox.routing.registerRoute(\n    new RegExp(`${location.host}/.*`),\n    workbox.strategies.staleWhileRevalidate()\n  );\n}\n\nfunction initPushNotifications() {\n  // HTML5 Push Notifications\n  function firePushCallback(payload, jwt) {\n    // Don't send the JWT in the payload.data\n    delete payload.data.jwt;\n    // If payload.data is empty then just remove the entire payload.data object.\n    if (Object.keys(payload.data).length === 0 && payload.data.constructor === Object) {\n      delete payload.data;\n    }\n    fetch('/api/notify.html5/callback', {\n      method: 'POST',\n      headers: new Headers({ 'Content-Type': 'application/json',\n        Authorization: 'Bearer ' + jwt }),\n      body: JSON.stringify(payload)\n    });\n  }\n\n  function notificationEventCallback(eventType, event) {\n    firePushCallback({\n      action: event.action,\n      data: event.notification.data,\n      tag: event.notification.tag,\n      type: eventType\n    }, event.notification.data.jwt);\n  }\n\n  self.addEventListener('push', function (event) {\n    var data;\n    if (event.data) {\n      data = event.data.json();\n      event.waitUntil(self.registration.showNotification(data.title, data)\n        .then(function (/* notification */) {\n          firePushCallback({\n            type: 'received',\n            tag: data.tag,\n            data: data.data\n          }, data.data.jwt);\n        }));\n    }\n  });\n\n  self.addEventListener('notificationclick', function (event) {\n    var url;\n\n    notificationEventCallback('clicked', event);\n\n    event.notification.close();\n\n    if (!event.notification.data || !event.notification.data.url) {\n      return;\n    }\n\n    url = event.notification.data.url;\n\n    if (!url) return;\n\n    event.waitUntil(clients.matchAll({\n      type: 'window',\n    })\n      .then(function (windowClients) {\n        var i;\n        var client;\n        for (i = 0; i < windowClients.length; i++) {\n          client = windowClients[i];\n          if (client.url === url && 'focus' in client) {\n            return client.focus();\n          }\n        }\n        if (clients.openWindow) {\n          return clients.openWindow(url);\n        }\n        return undefined;\n      }));\n  });\n\n  self.addEventListener('notificationclose', function (event) {\n    notificationEventCallback('closed', event);\n  });\n}\n\nworkbox.setConfig({\n  debug: __DEV__\n});\nworkbox.skipWaiting();\nworkbox.clientsClaim();\n\nif (!__DEV__) {\n  initRouting();\n}\n\ninitPushNotifications();\n"],"sourceRoot":""}